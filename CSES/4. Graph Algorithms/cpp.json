{"Planets Cycles": {"prefix": "Planets Cycles.cpp", "body": ["", "const int MAXN = 2e5, MAXM = 30;", "", "int n;", "vector<vector<int>> adj, cycles, revAdj;", "vector<int> cycleIdx, visited, pre, height, root, idx;", "int parent[MAXN][MAXM];", "int cycleCount = 0;", "int startCycle, finishCycle;", "", "void dfs(int u) {", "    visited[u] = 1;", "    for (int v : adj[u])", "        if (visited[v] == 0) {", "            pre[v] = u;", "            dfs(v);", "        }", "        else if (visited[v] == 1) {", "            startCycle = v;", "            finishCycle = u;", "        }", "    visited[u] = 2;", "}", "vector<int> restorePath(int s, int t, vector<int> const &pre) {", "    vector<int> path;", "    for (int v = t; v != s; v = pre[v]) ", "        path.push_back(v);", "    path.push_back(s);", "    reverse(path.begin(), path.end());", "    return path;", "}", "void dfs(int u, int r) {", "    cycleIdx[u] = cycleCount;", "    root[u] = r;", "    for (int v : revAdj[u])", "        if (height[v] == -1) {", "            height[v] = height[u] + 1;", "            dfs(v, r);", "        }", "}", "int succ(int x, int k) {", "    for (int j = 0; j < MAXM; j++)", "        if (k & (1 << j))", "            x = parent[x][j];", "    return x;", "}", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    cin >> n;", "    adj.resize(n);", "    revAdj.resize(n);", "    for (int v, u = 0; u < n; u++) {", "        cin >> v;", "        v--;", "        parent[u][0] = v;", "        adj[u].push_back(v);", "        revAdj[v].push_back(u);", "    }", "    for (int j = 1; j < MAXM; j++) ", "        for (int i = 0; i < n; i++)", "            parent[i][j] = parent[parent[i][j - 1]][j - 1];", "    cycleIdx.resize(n, -1);", "    visited.resize(n, 0);", "    pre.resize(n, -1);", "    height.resize(n, -1);", "    root.resize(n, -1);", "    idx.resize(n, -1);", "    for (int i = 0; i < n; i++) {", "        if (visited[i] == 0) {", "            startCycle = finishCycle = -1;", "            dfs(i);", "            if (startCycle != -1) {", "                cycles.push_back(restorePath(startCycle, finishCycle, pre));", "                for (int i = 0; i < cycles.back().size(); i++) {", "                    int u = cycles.back()[i];", "                    height[u] = 0;", "                    idx[u] = i;", "                }", "                for (int u : cycles.back())", "                    dfs(u, u);", "                cycleCount++;", "            }", "        }", "    }", "    for (int i = 0; i < n; i++) {", "        int u = i;", "        int res = height[u];", "        u = root[u];", "        int cycleSize = cycles[cycleIdx[u]].size();", "        res += cycleSize;", "        cout << res << \" \";", "    }", "    ", "    return 0;", "}"], "description": "Planets Cycles"}, "Flight Discount": {"prefix": "Flight Discount.cpp", "body": ["", "const long long INF = 1e18;", "vector<vector<pair<int, int>>> adj;", "", "long long Dijkstra(int s, int t) {", "    vector<vector<long long>> dist;", "    int n = adj.size(); ", "    dist.resize(n, vector<long long>(2, INF));", "    dist[s][0] = 0;", "", "    using pii = tuple<long long, int, bool>;", "    priority_queue<pii, vector<pii>, greater<pii>> pq;", "    pq.push({0, s, false});", "", "    while (!pq.empty()) {", "        auto [dist_u, u, used] = pq.top();", "        pq.pop();", "        if (dist_u != dist[u][used])", "            continue;", "        for (auto edge : adj[u]) {", "            auto [v, w] = edge;", "            if (dist[v][used] > dist_u + w) {", "                dist[v][used] = dist_u + w;", "                pq.push({dist[v][used], v, used});", "            }", "            if(used == false){", "                if (dist[v][!used] > dist_u + w/2) {", "                    dist[v][!used] = dist_u + w/2;", "                    pq.push({dist[v][!used], v, !used});", "                }", "            }", "        }", "    }", "    return min(dist[t][0], dist[t][1]);", "}", "", "int main() {", "    ios_base::sync_with_stdio(false);", "    cin.tie(0);", "    int n, m;", "    cin >> n >> m;", "    adj.resize(n);", "    for (int u, v, w, i = 0; i < m; i++) {", "        cin >> u >> v >> w;", "        u--, v--;", "        adj[u].push_back({v, w});", "    }", "    cout << Dijkstra(0, n - 1) << endl;", "    return 0;", "}"], "description": "Flight Discount"}, "Counting Rooms": {"prefix": "Counting Rooms.cpp", "body": ["/*", "    author: Minh Lam", "*/", "", "int dx[4] = {0, 0, 1, -1};", "int dy[4] = {1, -1, 0, 0};", "", "bool isValid(vector<vector<char>> &grid, int x, int y) {", "    int n = grid.size(), m = grid[0].size();", "    return x >= 0 && x < n && y >= 0 && y < m;", "}", "", "void DFS(int x, int y, vector<vector<char>> &grid, vector<vector<bool>> &visited) {", "    visited[x][y] = true;", "    for (int i = 0; i < 4; i++) {", "        int xx = x + dx[i];", "        int yy = y + dy[i];", "        if (isValid(grid, xx, yy) && grid[xx][yy] == '.' && !visited[xx][yy]) {", "            DFS(xx, yy, grid, visited);", "        }", "    }", "}", "", "int CountingRooms(int n, int m, vector<vector<char>> &grid) {", "    int res = 0;", "    vector<vector<bool>> visited(n, vector<bool>(m, false));", "    for (int i = 0; i < n; i++)", "        for (int j = 0; j < m; j++)", "            if (grid[i][j] == '.' && !visited[i][j]) {", "                DFS(i, j, grid, visited);", "                res++;", "            }", "    return res;", "}", "", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    int n, m; cin >> n >> m;", "    vector<vector<char>> grid(n, vector<char>(m));", "    for (int i = 0; i < n; i++)", "        for (int j = 0; j < m; j++)", "            cin >> grid[i][j];", "    cout << CountingRooms(n, m, grid) << endl;", "    return 0;", "}"], "description": "Counting Rooms"}, "Planets Queries I": {"prefix": "Planets Queries I.cpp", "body": ["", "const int MAXN = 2e5, MAXM = 30;", "", "int n, m, q;", "// vector<vector<int>> parent;", "int parent[MAXN][MAXM];", "", "int succ(int x, int k) {", "    for (int j = 0; j < MAXM; j++)", "        if (k & (1 << j))", "            x = parent[x][j];", "    return x;", "}", "", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    cin >> n >> q;", "    // m = ceil(log2(MAX)) + 1;", "    // parent.assign(n, vector<int>(m, -1));", "    for (int i = 0; i < n; ++i) {", "        cin >> parent[i][0];", "        parent[i][0]--;", "    }", "    for (int j = 1; j < MAXM; j++) ", "        for (int i = 0; i < n; i++)", "            parent[i][j] = parent[parent[i][j - 1]][j - 1];", "    while (q--) {", "        int x, k;", "        cin >> x >> k;", "        x--;", "        cout << succ(x, k) + 1 << '\\n';", "    }", "    return 0;", "}"], "description": "Planets Queries I"}, "Coin Collector": {"prefix": "Coin Collector.cpp", "body": ["#include <bits/stdc++.h>", "", "vector<vector<int>> adj;", "vector<int> low, num, sccId, coin;", "vector<bool> found;", "stack<int> st;", "vector<vector<int>> scc;", "int n, m;", "int counter;", "", "void dfs(int u) {", "    num[u] = low[u] = ++counter;", "    st.push(u);", "    for (int v : adj[u]) {", "        if (!found[v]) {", "            if (num[v] > 0)", "                low[u] = min(low[u], num[v]);", "            else {", "                dfs(v);", "                low[u] = min(low[u], low[v]);", "            }", "        }", "    }", "    if (num[u] == low[u]) {", "        // Found a SCC", "        int v;", "        scc.push_back(vector<int>());", "        do {", "            v = st.top();", "            st.pop();", "            scc.back().push_back(v);", "            sccId[v] = scc.size() - 1;", "            found[v] = true;", "        } while (v != u);", "    }", "}", "", "void Tarjan() {", "    counter = 0;", "    low.assign(n, 0);", "    num.assign(n, 0);", "    sccId.assign(n, -1);", "    found.assign(n, false);", "    st = stack<int>();", "    for (int i = 0; i < n; i++)", "        if (!num[i]) ", "            dfs(i);", "}", "", "vector<int> topo;", "vector<bool> visited;", "", "void DFS(int u) {", "    visited[u] = true;", "    for (int v : adj[u])", "        if (!visited[v])", "            DFS(v);", "    topo.push_back(u);", "}", "", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    cin >> n >> m;", "    adj.resize(n);", "    coin.resize(n);", "    for (int &x : coin) cin >> x;", "    while (m--) {", "        int u, v;", "        cin >> u >> v;", "        --u, --v;", "        adj[u].push_back(v);", "    }", "    Tarjan();", "    n = scc.size();", "    vector<vector<int>> adj2(n);", "    vector<long long> newCoin(n, 0), maxCoin(n);", "    for (int i = 0; i < n; i++) {", "        for (int u : scc[i]) {", "            newCoin[i] += 1ll * coin[u];", "            for (int v : adj[u])  {", "                if (sccId[v] != i) ", "                    adj2[i].push_back(sccId[v]);", "            }", "        }", "        maxCoin[i] = newCoin[i];", "    }", "    adj = adj2;", "    visited.assign(n, false);", "    for (int i = 0; i < n; i++)", "        if (!visited[i])", "            DFS(i);", "    reverse(topo.begin(), topo.end());", "    for (int u : topo) {", "        for (int v : adj[u]) {", "            maxCoin[v] = max(maxCoin[v], maxCoin[u] + newCoin[v]);", "        }", "    }", "    cout << *max_element(maxCoin.begin(), maxCoin.end()) << '\\n';", "    return 0;", "}"], "description": "Coin Collector"}, "High Score": {"prefix": "High Score.cpp", "body": ["#include <bits/stdc++.h>", "", "const long long INF = 1e18;", "vector<tuple<int, int, int>> edges;", "vector<vector<int>> adj;", "void dfs(int u, vector<bool> &visited) {", "    visited[u] = true;", "    for (int v : adj[u])", "        if (!visited[v])", "            dfs(v, visited);", "}", "void BellmanFord(vector<long long> &dist) {", "    int n = dist.size();", "    vector<int> lastChange;", "    for (int i = 0; i < n; i++) {", "        for (auto e : edges) {", "            int u, v, w;", "            tie(u, v, w) = e;", "            if (dist[u] != INF && dist[u] + w < dist[v]) {", "                dist[v] = dist[u] + w;", "                if (i == n - 1)", "                    lastChange.push_back(v);", "            }", "        }", "    }", "    vector<bool> visited(n, false);", "    for (int i : lastChange)", "        dfs(i, visited);", "    for (int i = 0; i < n; i++) ", "        if (visited[i])", "            dist[i] = -INF;", "}", "", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    int n, m;", "    cin >> n >> m;", "    edges.resize(m);", "    adj.resize(n);", "    for (auto &e : edges) {", "        int u, v, w;", "        cin >> u >> v >> w;", "        u--; v--;", "        e = {u, v, -w};", "        adj[u].push_back(v);", "    }", "    vector<long long> dist;", "    dist.assign(n, INF);", "    dist[0] = 0;", "    BellmanFord(dist);", "    if(dist[n - 1] != INF && dist[n - 1] != -INF) ", "        cout << -dist[n - 1] << endl;", "    else ", "        cout << -1 << endl;", "}"], "description": "High Score"}, "Knight's Tour": {"prefix": "Knight's Tour.cpp", "body": ["", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    int n, m;", "    cin >> n >> m;", "    ", "    return 0;", "}"], "description": "Knight's Tour"}, "Road Construction": {"prefix": "Road Construction.cpp", "body": ["", "const long long INF = 1e18;", "", "int n, m;", "vector<int> parent, setSize;", "", "void makeSet(int n) {", "    parent.resize(n);", "    setSize.resize(n, 1);", "    iota(parent.begin(), parent.end(), 0);", "}", "", "int findSet(int u) {", "    return parent[u] == u ? u : parent[u] = findSet(parent[u]);", "}", "", "bool unionSet(int u, int v) {", "    u = findSet(u);", "    v = findSet(v);", "    if (u == v) return false;", "    if (setSize[u] < setSize[v]) swap(u, v);", "    parent[v] = u;", "    setSize[u] += setSize[v];", "    return true;", "}", "", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    cin >> n >> m;", "    makeSet(n);", "    int components = n, maxSize = 1;", "    while(m--) {", "        int u, v;", "        cin >> u >> v;", "        --u, --v;", "        if (unionSet(u, v)) {", "            --components;", "            maxSize = max(maxSize, setSize[findSet(u)]);", "        }", "        cout << components << ' ' << maxSize << '\\n';", "    }", "    return 0;", "}"], "description": "Road Construction"}, "Building Roads": {"prefix": "Building Roads.cpp", "body": ["/*", "    author: Minh Lam", "*/", "", "void DFS(int u, vector<vector<int>> &graph, vector<bool> &visited) {", "    visited[u] = true;", "    for (int v : graph[u]) {", "        if (!visited[v]) {", "            DFS(v, graph, visited);", "        }", "    }", "}", "", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    int n, m;", "    cin >> n >> m;", "    vector<vector<int>> graph(n);", "    for (int i = 0; i < m; i++) {", "        int u, v;", "        cin >> u >> v;", "        u--; v--;", "        graph[u].push_back(v);", "        graph[v].push_back(u);", "    }", "    vector<int> points;", "    vector<bool> visited(n, false);", "    for (int i = 0; i < n; i++) {", "        if (!visited[i]) {", "            DFS(i, graph, visited);", "            points.push_back(i);", "        }", "    }", "    cout << points.size() - 1 << endl;", "    for (int i = 1; i < points.size(); i++) {", "        cout << points[i - 1] + 1 << \" \" << points[i] + 1 << endl;", "    }", "    return 0;", "}"], "description": "Building Roads"}, "Round Trip": {"prefix": "Round Trip.cpp", "body": ["", "vector<vector<int>> graph;", "vector<bool> visited, inStack;", "vector<int> parent;", "int start, finish;", "bool found = false;", "void DFS(int u) { ", "    visited[u] = inStack[u] = true;", "    for (int &v : graph[u]) {", "        if (!visited[v]) {", "            parent[v] = u;", "            DFS(v);", "        }", "        else if (v != parent[u] && inStack[v]) {", "            found = true;", "            start = v;", "            finish = u;", "        }", "    }", "    inStack[u] = false;", "}", "", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    int n, m;", "    cin >> n >> m;", "    graph.resize(n);", "    for (int u, v, i = 0; i < m; i++) {", "        cin >> u >> v;", "        u--; v--;", "        graph[u].push_back(v);", "        graph[v].push_back(u);", "    }", "    visited.resize(n, false);", "    inStack.resize(n, false);", "    parent.resize(n, -1);", "    for (int i = 0; i < n; i++) {", "        if (!found && !visited[i]) {", "            DFS(i);", "        }", "    }", "    if (!found) {", "        cout << \"IMPOSSIBLE\";", "    } else {", "        vector<int> ans = {start};", "        while (finish != start) {", "            ans.push_back(finish);", "            finish = parent[finish];", "        }", "        ans.push_back(start);", "        cout << ans.size() << endl;", "        for (int i = ans.size() - 1; i >= 0; i--) {", "            cout << ans[i] + 1 << \" \";", "        }", "        cout << endl;", "    }", "    return 0;", "}"], "description": "Round Trip"}, "Game Routes": {"prefix": "Game Routes.cpp", "body": ["", "const int MOD = 1e9 + 7;", "", "vector<vector<int>> adj;", "vector<int> visited, topo;", "", "void DFS(int u) {", "    visited[u] = 1;", "    for (int v : adj[u])", "        if (!visited[v])", "            DFS(v);", "    topo.push_back(u);", "}", "", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    int n, m;", "    cin >> n >> m;", "    adj.resize(n);", "    for (int u, v, i = 0; i < m; ++i) {", "        cin >> u >> v;", "        u--; v--;", "        adj[u].push_back(v);", "    }", "    visited.resize(n, false);", "    DFS(0);", "    reverse(topo.begin(), topo.end());", "    vector<int> numOfWays(n, 0);", "    numOfWays[0] = 1;", "    for (int u : topo)", "        for (int v : adj[u])", "            numOfWays[v] = (numOfWays[v] + numOfWays[u]) % MOD;", "    cout << numOfWays[n - 1];", "    return 0;", "}"], "description": "Game Routes"}, "Flight Routes": {"prefix": "Flight Routes.cpp", "body": ["", "#include <bits/stdc++.h>", "", "using ll = long long;", "", "const ll INF = 1e18;", "int n, m, k;", "vector<vector<pair<int, int>>> adj;", "", "vector<ll> Dijkstra(int s, int t) {", "    vector<multiset<ll>> dist;", "    dist.resize(n);", "", "    dist[s].insert(0);", "    using pii = pair<ll, int>;", "    priority_queue<pii, vector<pii>, greater<pii>> pq;", "    pq.push({0, s});", "    while (!pq.empty()) {", "        auto [dist_u, u] = pq.top();", "        pq.pop();", "        if(dist[u].count(dist_u) == 0) continue;", "        for (auto &edge : adj[u]) {", "            auto [v, w] = edge;", "            ll dist_v = dist_u + w;", "            if (dist[v].empty() || dist[v].size() < k) {", "                dist[v].insert(dist_v);", "                pq.push({dist_v, v});", "            } else {", "                auto last = dist[v].end();", "                last--;", "                if (dist_v < *last) {", "                    dist[v].erase(last);", "                    dist[v].insert(dist_v);", "                    pq.push({dist_v, v});", "                }", "            }", "        }", "    }", "    return vector<ll> (dist[n - 1].begin(), dist[n - 1].end());", "}", "int main() {", "    ios_base::sync_with_stdio(false);", "    cin.tie(0);", "    cin >> n >> m >> k;", "    adj.resize(n);", "    for (int u, v, w, i = 0; i < m; i++) {", "        cin >> u >> v >> w;", "        u--, v--;", "        adj[u].push_back({v, w});", "    }", "    vector<ll> lens = Dijkstra(0, n - 1);", "    for (ll len : lens)", "        cout << len << ' ';", "    return 0;", "}"], "description": "Flight Routes"}, "Planets Queries II": {"prefix": "Planets Queries II.cpp", "body": ["", "const int MAXN = 2e5, MAXM = 30;", "", "int n, q;", "vector<vector<int>> adj, cycles, revAdj;", "vector<int> cycleIdx, visited, pre, height, root, idx;", "int parent[MAXN][MAXM];", "int cycleCount = 0;", "int startCycle, finishCycle;", "", "void dfs(int u) {", "    visited[u] = 1;", "    for (int v : adj[u])", "        if (visited[v] == 0) {", "            pre[v] = u;", "            dfs(v);", "        }", "        else if (visited[v] == 1) {", "            startCycle = v;", "            finishCycle = u;", "        }", "    visited[u] = 2;", "}", "vector<int> restorePath(int s, int t, vector<int> const &pre) {", "    vector<int> path;", "    for (int v = t; v != s; v = pre[v]) ", "        path.push_back(v);", "    path.push_back(s);", "    reverse(path.begin(), path.end());", "    return path;", "}", "void dfs(int u, int r) {", "    cycleIdx[u] = cycleCount;", "    root[u] = r;", "    for (int v : revAdj[u])", "        if (height[v] == -1) {", "            height[v] = height[u] + 1;", "            dfs(v, r);", "        }", "}", "int succ(int x, int k) {", "    for (int j = 0; j < MAXM; j++)", "        if (k & (1 << j))", "            x = parent[x][j];", "    return x;", "}", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    cin >> n >> q;", "    adj.resize(n);", "    revAdj.resize(n);", "    for (int v, u = 0; u < n; u++) {", "        cin >> v;", "        v--;", "        parent[u][0] = v;", "        adj[u].push_back(v);", "        revAdj[v].push_back(u);", "    }", "    for (int j = 1; j < MAXM; j++) ", "        for (int i = 0; i < n; i++)", "            parent[i][j] = parent[parent[i][j - 1]][j - 1];", "    cycleIdx.resize(n, -1);", "    visited.resize(n, 0);", "    pre.resize(n, -1);", "    height.resize(n, -1);", "    root.resize(n, -1);", "    idx.resize(n, -1);", "    for (int i = 0; i < n; i++) {", "        if (visited[i] == 0) {", "            startCycle = finishCycle = -1;", "            dfs(i);", "            if (startCycle != -1) {", "                cycles.push_back(restorePath(startCycle, finishCycle, pre));", "                for (int i = 0; i < cycles.back().size(); i++) {", "                    int u = cycles.back()[i];", "                    height[u] = 0;", "                    idx[u] = i;", "                }", "                for (int u : cycles.back())", "                    dfs(u, u);", "                cycleCount++;", "            }", "        }", "    }", "    while (q--) {", "        int u, v, res = -1;", "        cin >> u >> v;", "        u--, v--;", "        if (cycleIdx[u] == cycleIdx[v]) {", "            if (root[u] == root[v]) {", "                if (height[u] >= height[v]) {", "                    int k = height[u] - height[v];", "                    if (succ(u, k) == v) res = k;", "                }", "            } else if (height[u] >= 0 && height[v] == 0) {", "                int cycleSize = cycles[cycleIdx[u]].size();", "                res = height[u];", "                u = root[u];", "                if (idx[u] < idx[v]) ", "                    res += idx[v] - idx[u];", "                else", "                    res += cycleSize - (idx[u] - idx[v]);", "                    ", "            }", "        }", "        cout << res << endl;", "    }", "    ", "    return 0;", "}"], "description": "Planets Queries II"}, "Building Teams": {"prefix": "Building Teams.cpp", "body": ["", "void DFS(int u, vector<vector<int>> &graph, vector<int> &color) {", "    for (int v : graph[u]) {", "        if (color[v] == 0) {", "            color[v] = color[u] == 1 ? 2 : 1;", "            DFS(v, graph, color);", "        } else if (color[v] == color[u]) {", "            cout << \"IMPOSSIBLE\" << endl;", "            exit(0);", "        }", "    }", "}", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    int n, m;", "    cin >> n >> m;", "    vector<vector<int>> graph(n);", "    for (int u, v, i = 0; i < m; i++) {", "        cin >> u >> v;", "        u--; v--;", "        graph[u].push_back(v);", "        graph[v].push_back(u);", "    }", "    vector<int> color(n, 0);", "    for (int i = 0; i < n; i++) {", "        if (color[i] == 0) {", "            color[i] = 1;", "            DFS(i, graph, color);", "        }", "    }", "    for (int c : color) cout << c << \" \";", "    return 0;", "}"], "description": "Building Teams"}, "Mail Delivery": {"prefix": "Mail Delivery.cpp", "body": ["#include <bits/stdc++.h>", "", "int n, m;", "vector<set<int>> adj;", "vector<int> degree;", "", "vector<int> Hierholzer(vector<set<int>> adj, int u) {", "    stack<int> path;", "    vector<int> circuit;", "    path.push(u);", "    while (!path.empty()) {", "        if (!adj[u].empty()) {", "            path.push(u);", "            int v = *adj[u].begin();", "            adj[u].erase(v);", "            adj[v].erase(u);", "            u = v;", "        }", "        else {", "            circuit.push_back(u);", "            u = path.top();", "            path.pop();", "        }", "    }", "    reverse(circuit.begin(), circuit.end());", "    return circuit;", "}", "", "vector<int> findEulerPath() {", "    vector<int> odds;", "    for (int i = 0; i < n; i++) ", "        if (degree[i] % 2 == 1)", "            odds.push_back(i);", "    if (odds.size() == 2) {", "        int s = odds[0], t = odds[1];", "        adj[s].insert(t);", "        adj[t].insert(s);", "        vector<int> circuit = Hierholzer(adj, odds[0]);", "        int last;", "        for (int i = 0; i < circuit.size() - 1; i++)", "            if (circuit[i] == t && circuit[i + 1] == s || circuit[i] == s && circuit[i + 1] == t) {", "                last = i;", "                break;", "            }", "        vector<int> ans(circuit.begin() + last + 1, circuit.end());", "        for (int j = 1; j <= last; j++)", "            ans.push_back(circuit[j]);", "        return ans;", "    } ", "    if (odds.size() == 0) ", "        return Hierholzer(adj, 0);", "    return {};", "}", "", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    cin >> n >> m;", "    adj.resize(n);", "    degree.resize(n);", "    for (int u, v, i = 0; i < m; i++) {", "        cin >> u >> v;", "        --u, --v;", "        adj[u].insert(v);", "        adj[v].insert(u);", "        degree[u]++;", "        degree[v]++;", "    }", "    vector<int> circuit = findEulerPath();", "    if (circuit.size() != m + 1)", "        cout << \"IMPOSSIBLE\";", "    else", "        for (int i : circuit)", "            cout << i + 1 << \" \";", "    return 0;", "}"], "description": "Mail Delivery"}, "Planets and Kingdoms": {"prefix": "Planets and Kingdoms.cpp", "body": ["#include <bits/stdc++.h>", "", "vector<vector<int>> adj;", "vector<int> low, num, sccId;", "vector<bool> found;", "stack<int> st;", "vector<vector<int>> scc;", "int n, m;", "int counter;", "", "void dfs(int u) {", "    num[u] = low[u] = ++counter;", "    st.push(u);", "    for (int v : adj[u]) {", "        if (!found[v]) {", "            if (num[v] > 0)", "                low[u] = min(low[u], num[v]);", "            else {", "                dfs(v);", "                low[u] = min(low[u], low[v]);", "            }", "        }", "    }", "    if (num[u] == low[u]) {", "        // Found a SCC", "        int v;", "        scc.push_back(vector<int>());", "        do {", "            v = st.top();", "            st.pop();", "            scc.back().push_back(v);", "            sccId[v] = scc.size() - 1;", "            found[v] = true;", "        } while (v != u);", "    }", "}", "", "void Tarjan() {", "    counter = 0;", "    low.assign(n, 0);", "    num.assign(n, 0);", "    sccId.assign(n, -1);", "    found.assign(n, false);", "    st = stack<int>();", "    for (int i = 0; i < n; i++)", "        if (!num[i]) ", "            dfs(i);", "}", "", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    cin >> n >> m;", "    adj.resize(n);", "    while (m--) {", "        int u, v;", "        cin >> u >> v;", "        --u, --v;", "        adj[u].push_back(v);", "    }", "    Tarjan();", "    cout << scc.size() << '\\n';", "    for (int i = 0; i < n; i++)", "        cout << sccId[i] + 1 << ' ';", "    return 0;", "}"], "description": "Planets and Kingdoms"}, "Labyrinth": {"prefix": "Labyrinth.cpp", "body": ["/*", "    author: Minh Lam", "*/", "", "int dx[4] = {0, 0, 1, -1};", "int dy[4] = {1, -1, 0, 0};", "string d = \"RLDU\";", "int n, m; ", "vector<vector<char>> grid;", "vector<vector<bool>> visited;", "vector<vector<pair<int, int>>> path;", "string res;", "", "bool isValid(int x, int y) {", "    return x >= 0 && x < n && y >= 0 && y < m;", "}", "", "void BFS(int sx, int sy) {", "    queue<pair<int, int>> q;", "    q.push({sx, sy});", "    visited[sx][sy] = true;", "    while (!q.empty()) {", "        int x = q.front().first, y = q.front().second;", "        q.pop();", "        for (int i = 0; i < 4; i++) {", "            int xx = x + dx[i];", "            int yy = y + dy[i];", "            if (isValid(xx, yy) && grid[xx][yy] != '#' && !visited[xx][yy]) {", "                q.push({xx, yy});", "                path[xx][yy] = {x, y};", "                visited[xx][yy] = true;", "            }", "        }   ", "    }", "}", "", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    cin >> n >> m;", "    grid.resize(n, vector<char>(m));", "    visited.resize(n, vector<bool>(m, false));", "    path.resize(n, vector<pair<int, int>>(m));", "    for (int i = 0; i < n; i++)", "        for (int j = 0; j < m; j++)", "            cin >> grid[i][j];", "    pair<int, int> finish, start;  ", "    for (int i = 0; i < n; i++)", "        for (int j = 0; j < m; j++) {", "            if (grid[i][j] == 'A') {", "                BFS(i, j);", "                start = {i, j};", "            } ", "            if (grid[i][j] == 'B') {", "                finish = {i, j};", "            }", "        }", "", "    if (visited[finish.first][finish.second]) {", "        int x = finish.first, y = finish.second;", "        while (x != start.first || y != start.second) {", "            auto p = path[x][y];", "            for (int i = 0; i < 4; i++) {", "                if (x - p.first == dx[i] && y - p.second == dy[i]) {", "                    res += d[i];", "                    break;", "                }", "            }", "            x = p.first;", "            y = p.second;", "        }", "        cout << \"YES\" << endl;", "        cout << res.length() << endl;", "        reverse(res.begin(), res.end());", "        cout << res << endl;", "    } else {", "        cout << \"NO\" << endl;", "    }", "    return 0;", "}"], "description": "Labyrinth"}, "Cycle Finding": {"prefix": "Cycle Finding.cpp", "body": ["#include <bits/stdc++.h>", "", "namespace BellmanFordSpace{", "    const long long INF = 1e18;", "    vector<tuple<int, int, int>> edges;", "    vector<long long> dist;", "    vector<int> prev;", "    int n, m, lastChange = -1;", "    bool hasNegativeCycle = false;", "    void BellmanFord(vector<int> starts) {", "        dist.assign(n, INF);", "        prev.assign(n, -1);", "        for (int &s : starts)", "            dist[s] = 0;", "        for (int i = 0; i < n; i++) {", "            bool changed = false;", "            for (auto e : edges) {", "                int u, v, w;", "                tie(u, v, w) = e;", "                if (dist[u] < INF && dist[u] + w < dist[v]) {", "                    dist[v] = dist[u] + w;", "                    prev[v] = u;", "                    changed = true;", "                    if (i == n - 1) lastChange = v;", "                }", "            }", "            if (i == n - 1 && changed) hasNegativeCycle = true;", "            if (!changed) return;", "        }", "    }", "    vector<int> negativeCycle() {", "        if (lastChange == -1) return {};", "        int n = prev.size();", "        int v = lastChange;", "        for (int i = 0; i < n; ++i)", "            v = prev[v];", "        int u = v;", "        vector<int> cycle;", "        while (true) {", "            v = prev[v];", "            cycle.push_back(v);", "            if (v == u && cycle.size() > 1)", "                break;", "        }", "        reverse(cycle.begin(), cycle.end());", "        if (cycle.front() != cycle.back())", "            cycle.push_back(cycle.front());", "        return cycle;", "    }", "}", "using namespace BellmanFordSpace;", "", "namespace ComponentFindingSpace{", "    vector<vector<int>> graph;", "    vector<int> component, starts;", "    int componentCount = 0;", "    void DFS(int u, int c) {", "        component[u] = c;", "        for (int v : graph[u])", "            if (component[v] == -1) ", "                DFS(v, c);", "    }", "    void findComponents() {", "        int n = graph.size();", "        component.assign(n, -1);", "        for (int i = 0; i < n; i++)", "            if (component[i] == -1) {", "                DFS(i, ++componentCount);", "                starts.push_back(i);", "            }", "    }", "}", "using namespace ComponentFindingSpace;", "", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    cin >> n >> m;", "    edges.resize(m);", "    graph.resize(n);", "    for (auto &e : edges) {", "        int u, v, w;", "        cin >> u >> v >> w;", "        u--; v--;", "        graph[u].push_back(v);", "        e = {u, v, w};", "    }", "    findComponents();", "    BellmanFord(starts);", "    if (hasNegativeCycle) {", "        cout << \"YES\" << endl;", "        vector<int> cycle = negativeCycle();", "        for (int v : cycle)", "            cout << v + 1 << \" \";", "    } else {", "        cout << \"NO\" << endl;", "    }", "}"], "description": "Cycle Finding"}, "Message Route": {"prefix": "Message Route.cpp", "body": ["", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    int n, m;", "    cin >> n >> m;", "    vector<vector<int>> graph(n);", "    for (int i = 0; i < m; i++) {", "        int u, v;", "        cin >> u >> v;", "        u--; v--;", "        graph[u].push_back(v);", "        graph[v].push_back(u);", "    }    ", "    queue<int> q;", "    vector<int> path(n, -1);", "    vector<bool> visited(n, false);", "    q.push(0);", "    visited[0] = true;", "    while (!q.empty()) {", "        int u = q.front();", "        q.pop();", "        for (int v : graph[u]) {", "            if (!visited[v]) {", "                path[v] = u;", "                visited[v] = true;", "                q.push(v);", "            }", "        }", "    }", "    if (path[n - 1] == -1) {", "        cout << \"IMPOSSIBLE\" << endl;", "    } else {", "        vector<int> ans;", "        int u = n - 1;", "        while (u != -1) {", "            ans.push_back(u);", "            u = path[u];", "        }", "        cout << ans.size() << endl;", "        for (int i = ans.size() - 1; i >= 0; i--) {", "            cout << ans[i] + 1 << \" \";", "        }", "        cout << endl;", "    }", "    return 0;", "}"], "description": "Message Route"}, "Teleporters Path": {"prefix": "Teleporters Path.cpp", "body": ["#include <bits/stdc++.h>", "", "int n, m;", "vector<vector<int>> adj;", "vector<int> indegree, outdegree;", "", "vector<int> Hierholzer(vector<vector<int>> adj, int u) {", "    stack<int> path;", "    vector<int> circuit;", "    path.push(u);", "    while (!path.empty()) {", "        if (!adj[u].empty()) {", "            path.push(u);", "            int v = adj[u].back();", "            adj[u].pop_back();", "            u = v;", "        }", "        else {", "            circuit.push_back(u);", "            u = path.top();", "            path.pop();", "        }", "    }", "    reverse(circuit.begin(), circuit.end());", "    return circuit;", "}", "", "vector<int> findEulerPath(int s, int t) {", "    for (int i = 0; i < n; i++) {", "        if (i != s && i != t && indegree[i] != outdegree[i])", "            return {};", "    }", "    int ds = outdegree[s] - indegree[s], dt = indegree[t] - outdegree[t];", "    if (ds == dt && ds == 1) {", "        adj[t].push_back(s);", "        vector<int> circuit = Hierholzer(adj, s);", "        int last;", "        for (int i = 0; i < circuit.size() - 1; i++)", "            if (circuit[i] == t && circuit[i + 1] == s) {", "                last = i;", "                break;", "            }", "        vector<int> ans(circuit.begin() + last + 1, circuit.end());", "        for (int j = 1; j <= last; j++)", "            ans.push_back(circuit[j]);", "        return ans;", "    }", "    return {};", "}", "", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    cin >> n >> m;", "    adj.resize(n);", "    indegree.resize(n);", "    outdegree.resize(n);", "    for (int u, v, i = 0; i < m; i++) {", "        cin >> u >> v;", "        --u, --v;", "        adj[u].push_back(v);", "        indegree[v]++;", "        outdegree[u]++;", "    }", "    vector<int> circuit = findEulerPath(0, n - 1);", "    if (circuit.size() != m + 1)", "        cout << \"IMPOSSIBLE\";", "    else", "        for (int i : circuit)", "            cout << i + 1 << \" \";", "    return 0;", "}"], "description": "Teleporters Path"}, "Road Reparation": {"prefix": "Road Reparation.cpp", "body": ["", "const long long INF = 1e18;", "", "struct Edge {", "    int u, v, w;", "    bool operator<(const Edge& other) const {", "        return w < other.w;", "    }", "};", "", "int n, m;", "vector<Edge> edges;", "vector<int> parent, setSize;", "long long mst;", "", "void makeSet(int n) {", "    parent.resize(n);", "    setSize.resize(n, 1);", "    iota(parent.begin(), parent.end(), 0);", "}", "", "int findSet(int u) {", "    return parent[u] == u ? u : parent[u] = findSet(parent[u]);", "}", "", "bool unionSet(int u, int v) {", "    u = findSet(u);", "    v = findSet(v);", "    if (u == v) return false;", "    if (setSize[u] < setSize[v]) swap(u, v);", "    parent[v] = u;", "    setSize[u] += setSize[v];", "    return true;", "}", "", "bool Kruskal() {", "    makeSet(n);", "    sort(edges.begin(), edges.end());", "    int cnt = mst = 0;", "    for (const Edge &e : edges)", "        if (unionSet(e.u, e.v)) {", "            mst += 1ll * e.w;", "            cnt++;", "        }", "    return cnt == n - 1;", "}", "", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    cin >> n >> m;", "    edges.resize(m);", "    for (auto &e : edges) {", "        int u, v, w;", "        cin >> u >> v >> w;", "        --u, --v;", "        e = {u, v, w};", "    }", "    if (Kruskal())", "        cout << mst;", "    else", "        cout << \"IMPOSSIBLE\";", "    return 0;", "}"], "description": "Road Reparation"}, "Shortest Routes II": {"prefix": "Shortest Routes II.cpp", "body": ["", "const long long INF = 1e18;", "", "void FloydWarshall(int n, vector<vector<long long>> &dist) {", "    for (int k = 0; k < n; ++k)", "        for (int i = 0; i < n; ++i)", "            for (int j = 0; j < n; ++j)", "                if (dist[i][k] < INF && dist[k][j] < INF)", "                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); ", "}", "", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    int n, m, q;", "    cin >> n >> m >> q;", "    vector<vector<long long>> dist;", "    dist.resize(n, vector<long long>(n, INF));", "    for (int i = 0; i < n; i++)", "        dist[i][i] = 0;", "    for (int i = 0; i < m; i++) {", "        int u, v, w;", "        cin >> u >> v >> w;", "        u--; v--;", "        dist[u][v] = min(dist[u][v], (long long)w);", "        dist[v][u] = min(dist[v][u], (long long)w);", "    }", "    FloydWarshall(n, dist);", "    while(q--) {", "        int u, v;", "        cin >> u >> v;", "        u--; v--;", "        cout << (dist[u][v] == INF ? -1 : dist[u][v]) << endl;", "    }", "    return 0;", "}"], "description": "Shortest Routes II\nVerified: https://cses.fi/problemset/task/1672"}, "Shortest Routes I": {"prefix": "Shortest Routes I.cpp", "body": ["#include <bits/stdc++.h>", "", "const long long INF = 1e18;", "vector<vector<pair<int, int>>> adj;", "void dijkstra(int s, vector<long long> &dist, vector<int> &prev) {", "    int n = adj.size();", "    dist.assign(n, INF);", "    prev.assign(n, -1);", "", "    dist[s] = 0;", "    using pii = pair<long long, int>;", "    priority_queue<pii, vector<pii>, greater<pii>> pq;", "    pq.push({0, s});", "    while (!pq.empty()) {", "        int u = pq.top().second;", "        long long dist_u = pq.top().first;", "        pq.pop();", "        if (dist_u != dist[u])", "            continue;", "", "        for (auto &edge : adj[u]) {", "            int v = edge.first;", "            int w = edge.second;", "            if (dist[v] > dist[u] + w) {", "                dist[v] = dist[u] + w;", "                prev[v] = u;", "                pq.push({dist[v], v});", "            }", "        }", "    }", "}", "vector<int> restorePath(int s, int t, vector<int> const &prev) {", "    vector<int> path;", "    for (int v = t; v != s; v = prev[v])", "        path.push_back(v);", "    path.push_back(s);", "    reverse(path.begin(), path.end());", "    return path;", "}", "", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    int n, m;", "    cin >> n >> m;", "    adj.resize(n);", "    for (int i = 0; i < m; i++) {", "        int u, v, w;", "        cin >> u >> v >> w;", "        u--; v--;", "        adj[u].push_back({v, w});", "    }", "    vector<long long> dist;", "    vector<int> prev;", "    dijkstra(0, dist, prev);", "    for (int i = 0; i < n; i++) {", "        cout << dist[i] << ' ';", "    }", "    return 0;", "}"], "description": "Shortest Routes I\nVerified: https://cses.fi/problemset/task/1671/"}, "Monsters": {"prefix": "Monsters.cpp", "body": ["/*", "    author: Minh Lam", "*/", "", "int n, m;", "vector<vector<char>> grid;", "vector<pair<int, int>> monsters;", "vector<vector<int>> dist;", "vector<vector<bool>> visited;", "pair<int, int> human;", "", "int dx[] = {0, 0, 1, -1};", "int dy[] = {1, -1, 0, 0};", "", "void BFS(int x, int y) {", "    queue<pair<int, int>> q;", "    q.push({x, y});", "    visited[x][y] = true;", "    dist[x][y] = 0;", "    while (!q.empty()) {", "        int u, v;", "        tie(u, v) = q.front();", "        q.pop();", "        for (int i = -1; i <= 1; i++) {", "            for (int j = -1; j <= 1; j++) {", "                if (abs(i) + abs(j) == 1) {", "                    int x = u + i, y = v + j;", "                    if (x >= 0 && x < n && y >= 0 && y < m && grid[x][y] != '#' && !visited[x][y]) {", "                        visited[x][y] = true;", "                        dist[x][y] = dist[u][v] + 1;", "                        q.push({x, y});", "                    }", "                }", "            }", "        }", "    }", "}", "", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    cin >> n >> m;", "    grid.resize(n, vector<char>(m));", "    ", "    for (int i = 0; i < n; i++) {", "        for (int j = 0; j < m; j++) {", "            cin >> grid[i][j];", "            if (grid[i][j] == 'A') {", "                human = {i, j};", "            } else if (grid[i][j] == 'M') {", "                monsters.push_back({i, j});", "            }", "        }", "    }", "    dist.resize(n, vector<int>(m, -1));", "    visited.resize(n, vector<bool>(m, false));", "    for (auto &monster : monsters) {", "        BFS(monster);", "    }", "    return 0;", "}"], "description": "Monsters"}, "Investigation": {"prefix": "Investigation.cpp", "body": ["", "const long long INF = 1e18;", "const int MOD = 1e9 + 7;", "", "int n, m;", "vector<vector<pair<int, int>>> adj;", "vector<long long> dist;", "vector<int> pre, cnt, minLen, maxLen;", "", "void dijkstra(int s) {", "    dist.assign(n, INF);", "    pre.assign(n, -1);", "    cnt.assign(n, 0);", "    minLen.assign(n, 0);", "    maxLen.assign(n, 0);", "", "    dist[s] = 0;", "    cnt[s] = 1;", "    using pii = pair<long long, int>;", "    priority_queue<pii, vector<pii>, greater<pii>> pq;", "    pq.push({0, s});", "", "    while (!pq.empty()) {", "        int u = pq.top().second;", "        long long dist_u = pq.top().first;", "        pq.pop();", "        if (dist_u != dist[u])", "            continue;", "", "        for (auto &edge : adj[u]) {", "            int v = edge.first;", "            int w = edge.second;", "            if (dist[v] > dist[u] + w) {", "                dist[v] = dist[u] + w;", "                cnt[v] = cnt[u];", "                minLen[v] = minLen[u] + 1;", "                maxLen[v] = maxLen[u] + 1;", "                pre[v] = u;", "                pq.push({dist[v], v});", "            }", "            else if (dist[v] == dist[u] + w) {", "                cnt[v] = (cnt[v] + cnt[u]) % MOD;", "                minLen[v] = min(minLen[v], minLen[u] + 1);", "                maxLen[v] = max(maxLen[v], maxLen[u] + 1);", "            }", "        }", "    }", "}", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    cin >> n >> m;", "    adj.resize(n);", "    for (int u, v, w, i = 0; i < m; ++i) {", "        cin >> u >> v >> w;", "        u--; v--;", "        adj[u].push_back({v, w});", "    }", "    dijkstra(0);", "    cout << dist[n - 1] << ' ' << cnt[n - 1] << ' ' << minLen[n - 1] << ' ' << maxLen[n - 1];", "    return 0;", "}"], "description": "Investigation"}, "Longest Flight Route": {"prefix": "Longest Flight Route.cpp", "body": ["", "vector<vector<int>> adj;", "vector<int> visited, topo;", "", "void DFS(int u) {", "    visited[u] = 1;", "    for (int v : adj[u])", "        if (!visited[v])", "            DFS(v);", "    topo.push_back(u);", "}", "vector<int> restore_path(int s, int t, vector<int> const &prev) {", "    vector<int> path;", "    for (int v = t; v != -1; v = prev[v])", "        path.push_back(v);", "    reverse(path.begin(), path.end());", "    return path;", "}", "", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    int n, m;", "    cin >> n >> m;", "    adj.resize(n);", "    for (int u, v, i = 0; i < m; ++i) {", "        cin >> u >> v;", "        u--; v--;", "        adj[u].push_back(v);", "    }", "    visited.resize(n, false);", "    DFS(0);", "    reverse(topo.begin(), topo.end());", "    vector<int> dist(n, 0), prev(n, -1);", "    for (int u : topo)", "        for (int v : adj[u])", "            if (dist[v] < dist[u] + 1) {", "                dist[v] = dist[u] + 1;", "                prev[v] = u;", "            }", "    if (dist[n - 1] == 0)", "        cout << \"IMPOSSIBLE\";", "    else {", "        cout << dist[n - 1] + 1 << endl;", "        vector<int> path = restore_path(0, n - 1, prev);", "        for (int u : path)", "            cout << u + 1 << ' ';", "    }", "    return 0;", "}"], "description": "Longest Flight Route"}, "Hamiltonian Flights": {"prefix": "Hamiltonian Flights.cpp", "body": ["#include <bits/stdc++.h>", " ", "const int MOD = 1e9 + 7;", " ", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    int n, m;", "    cin >> n >> m;", "    vector<vector<int>> adj(n);", "    for (int u, v, i = 0; i < m; i++) {", "        cin >> u >> v;", "        --u, --v;", "        adj[v].push_back(u);", "    }", "    vector<vector<int>> dp(n, vector<int>(1 << n, 0));", "    dp[0][1] = 1;", "    for (int state = 1; state < (1 << n); state++) {", "        bool isLast = (state == (1 << n) - 1);", "        bool hasLast = state & (1 << (n - 1));", "        if (!isLast && hasLast) continue;", "        for (int v = n - 1; v >= 0; v--) {", "            if ((state >> v) & 1) {", "                for (const int &u : adj[v]) {", "                    if ((state >> v) & 1) {", "                        dp[v][state] += dp[u][state ^ (1 << v)];", "                        dp[v][state] %= MOD;", "                    }", "                }", "            }", "        }", "        if (isLast) break;", "    }", "    cout << dp[n - 1][(1 << n) - 1];", "    return 0;", "}"], "description": "Hamiltonian Flights"}, "Round Trip II": {"prefix": "Round Trip II.cpp", "body": [" ", "vector<vector<int>> graph;", "vector<bool> visited, inStack;", "vector<int> parent;", "int start, finish;", "bool found = false;", "void DFS(int u) { ", "    visited[u] = inStack[u] = true;", "    for (int &v : graph[u]) {", "        if (!visited[v]) {", "            parent[v] = u;", "            DFS(v);", "        }", "        else if (inStack[v]) {", "            found = true;", "            start = v;", "            finish = u;", "        }", "    }", "    inStack[u] = false;", "}", " ", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    int n, m;", "    cin >> n >> m;", "    graph.resize(n);", "    for (int u, v, i = 0; i < m; i++) {", "        cin >> u >> v;", "        u--; v--;", "        graph[u].push_back(v);", "    }", "    visited.resize(n, false);", "    inStack.resize(n, false);", "    parent.resize(n, -1);", "    for (int i = 0; i < n; i++) {", "        if (!found && !visited[i]) {", "            DFS(i);", "        }", "    }", "    if (!found) {", "        cout << \"IMPOSSIBLE\";", "    } else {", "        vector<int> ans = {start};", "        while (finish != start) {", "            ans.push_back(finish);", "            finish = parent[finish];", "        }", "        ans.push_back(start);", "        cout << ans.size() << endl;", "        for (int i = ans.size() - 1; i >= 0; i--) {", "            cout << ans[i] + 1 << \" \";", "        }", "        cout << endl;", "    }", "    return 0;", "}"], "description": "Round Trip II"}, "Course Schedule": {"prefix": "Course Schedule.cpp", "body": ["", "vector<vector<int>> adj;", "vector<int> visited, topo;", "bool hasCycle;", "void dfs(int u) {", "    visited[u] = 1;", "    for (int v : adj[u]) {", "        if (visited[v] == 0)", "            dfs(v);", "        else if (visited[v] == 1)", "            hasCycle = true;", "    }", "    topo.push_back(u);", "    visited[u] = 2;", "}", "", "int main() {", "    ios_base::sync_with_stdio(false);", "    cin.tie(0);", "    int n, m;", "    cin >> n >> m;", "    adj.resize(n);", "    for (int u, v, i = 0; i < m; i++) {", "        cin >> u >> v;", "        u--, v--;", "        adj[u].push_back(v);", "    }", "    visited.resize(n, 0);", "    for (int v = 0; v < n; v++) ", "        if (visited[v] == 0)", "            dfs(v);", "    if (hasCycle)", "        cout << \"IMPOSSIBLE\" << endl;", "    else {", "        reverse(topo.begin(), topo.end());", "        for (int v : topo)", "            cout << v + 1 << ' ';", "        cout << endl;", "    }", "    return 0;", "}"], "description": "Course Schedule"}, "Flight Routes Check": {"prefix": "Flight Routes Check.cpp", "body": ["#include <bits/stdc++.h>", "", "vector<vector<int>> adj;", "vector<int> low, num;", "vector<bool> found;", "stack<int> st;", "vector<vector<int>> scc;", "int n, m;", "int counter;", "", "void dfs(int u) {", "    num[u] = low[u] = ++counter;", "    st.push(u);", "    for (int v : adj[u]) {", "        if (!found[v]) {", "            if (num[v] > 0)", "                low[u] = min(low[u], num[v]);", "            else {", "                dfs(v);", "                low[u] = min(low[u], low[v]);", "            }", "        }", "    }", "    if (num[u] == low[u]) {", "        // Found a SCC", "        int v;", "        scc.push_back(vector<int>());", "        do {", "            v = st.top();", "            st.pop();", "            scc.back().push_back(v);", "            found[v] = true;", "        } while (v != u);", "    }", "}", "", "void Tarjan() {", "    counter = 0;", "    low.assign(n, 0);", "    num.assign(n, 0);", "    found.assign(n, false);", "    st = stack<int>();", "    for (int i = 0; i < n; i++)", "        if (!num[i]) ", "            dfs(i);", "}", "", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    cin >> n >> m;", "    adj.resize(n);", "    while (m--) {", "        int u, v;", "        cin >> u >> v;", "        --u, --v;", "        adj[u].push_back(v);", "    }", "    Tarjan();", "    if (scc.size() == 1)", "        cout << \"YES\";", "    else {", "        cout << \"NO\" << endl;", "        cout << scc[0][0]+ 1 << ' ' << scc[1][0] + 1;", "    }", "    return 0;", "}"], "description": "Flight Routes Check"}, "De Bruijn Sequence": {"prefix": "De Bruijn Sequence.cpp", "body": ["// https://www.geeksforgeeks.org/de-bruijn-sequence-set-1/", "", "vector<int> Hierholzer(vector<vector<int>> adj, int u = 0) {", "    stack<int> path;", "    vector<int> circuit;", "    path.push(u);", "    while (!path.empty()) {", "        if (!adj[u].empty()) {", "            path.push(u);", "            int v = adj[u].back();", "            adj[u].pop_back();", "            u = v;", "        }", "        else {", "            circuit.push_back(u);", "            u = path.top();", "            path.pop();", "        }", "    }", "    reverse(circuit.begin(), circuit.end());", "    return circuit;", "}", "string printBit(int x, int n){", "    string s = \"\";", "    for(int i = n - 1; i >= 0; i--){", "        s += (x & (1 << i)) ? '1' : '0';", "    }", "    return s;", "}", "int main() {", "    cin.tie(nullptr)->sync_with_stdio(false);", "    int n; cin >> n;", "    if (n == 1) return cout << \"01\\n\", 0;", "    n--;", "    vector<vector<int>> adj(1 << n);", "    for (int i = 0; i < (1 << n); i++) {", "        int j = (i & ~(1 << (n - 1))) << 1;", "        adj[i].push_back(j);", "        adj[i].push_back(j + 1);", "    }", "    vector<int> circuit = Hierholzer(adj);", "    string res = printBit(circuit[0], n);", "    for (int i = 1; i < circuit.size(); i++) {", "        res += (circuit[i] & 1) ? '1' : '0';", "    }", "    cout << res;", "    return 0;", "}"], "description": "De Bruijn Sequence"}}