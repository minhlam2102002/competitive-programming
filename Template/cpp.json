{
    "template": {
        "prefix": "cpp/template",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "int main() {",
            "    cin.tie(nullptr)->sync_with_stdio(false);",
            "    $1",
            "    return 0;",
            "}"
        ],
        "description": "template"
    },
    "algebra": {
        "prefix": "Algebra/algebra.cpp",
        "body": [
            "// Binary Exponentiation",
            "// https://cp-algorithms.com/algebra/binary-exp.html",
            "long long binpow(long long a, long long b) {",
            "    long long res = 1;",
            "    while (b > 0) {",
            "        if (b & 1)",
            "            res = res * a;",
            "        a = a * a;",
            "        b >>= 1;",
            "    }",
            "    return res;",
            "}",
            "long long binpow(long long a, long long b, long long m) {",
            "    // if m is prime, then caculate (a^(b mod(m-1))) % m instead of (a^b) % m due to Fermat's Little Theorem",
            "    a %= m;",
            "    long long res = 1;",
            "    while (b > 0) {",
            "        if (b & 1)",
            "            res = res * a % m;",
            "        a = a * a % m;",
            "        b >>= 1;",
            "    }",
            "    return res;",
            "}",
            "",
            "// Sieve of Eratosthenes",
            "void sieve(vector<bool> &is_prime, int n) {",
            "    // Time complexity: O(n log log sqrt(n))",
            "    vector<bool> is_prime(n+1, true);",
            "    is_prime[0] = is_prime[1] = false;",
            "    for (int i = 2; i * i <= n; i++) ",
            "        if (is_prime[i]) ",
            "            for (int j = i * i; j <= n; j += i)",
            "                is_prime[j] = false;",
            "}",
            "vector<char> segmentedSieve(long long L, long long R) {",
            "    long long lim = sqrt(R);",
            "    vector<char> mark(lim + 1, false);",
            "    vector<long long> primes;",
            "    for (long long i = 2; i <= lim; ++i) {",
            "        if (!mark[i]) {",
            "            primes.emplace_back(i);",
            "            for (long long j = i * i; j <= lim; j += i)",
            "                mark[j] = true;",
            "        }",
            "    }",
            "",
            "    vector<char> isPrime(R - L + 1, true);",
            "    for (long long i : primes)",
            "        for (long long j = max(i * i, (L + i - 1) / i * i); j <= R; j += i)",
            "            isPrime[j - L] = false;",
            "    if (L == 1)",
            "        isPrime[0] = false;",
            "    return isPrime;",
            "}",
            "",
            "bool isPrime(int x) {",
            "    for (int d = 2; d * d <= x; d++)",
            "        if (x % d == 0)",
            "            return false;",
            "    return true;",
            "}",
            "",
            "bool probablyPrimeFermat(int n, int iter=5) {",
            "    if (n < 4)",
            "        return n == 2 || n == 3;",
            "",
            "    for (int i = 0; i < iter; i++) {",
            "        int a = 2 + rand() % (n - 3);",
            "        if (binpow(a, n - 1, n) != 1)",
            "            return false;",
            "    }",
            "    return true;",
            "}",
            "",
            "vector<long long> trial_division1(long long n) {",
            "    vector<long long> factorization;",
            "    for (long long d = 2; d * d <= n; d++) ",
            "        while (n % d == 0) {",
            "            factorization.push_back(d);",
            "            n /= d;",
            "        }",
            "    if (n > 1)",
            "        factorization.push_back(n);",
            "    return factorization;",
            "}"
        ],
        "description": "algebra"
    },
    "FenwickTree": {
        "prefix": "DataStructure/FenwickTree.cpp",
        "body": [
            "",
            "struct FenwickTree {",
            "    vector<long long> ft;",
            "    int n;",
            "",
            "    FenwickTree(int n) {",
            "        this->n = n;",
            "        ft.assign(n + 1, 0);",
            "    }",
            "    void update(int id, int val) {",
            "        while (id <= n) {",
            "            ft[id] += 1ll * val;",
            "            id += id & -id;",
            "        }",
            "    }",
            "    long long query(int id) {",
            "        long long sum = 0;",
            "        while (id > 0) {",
            "            sum += 1ll * ft[id];",
            "            id -= id & -id;",
            "        }",
            "        return sum;",
            "    }",
            "    long long query(int l, int r) {",
            "        return query(r) - query(l - 1);",
            "    }",
            "};"
        ],
        "description": "FenwickTree\nVerified: https://cses.fi/problemset/task/1648/"
    },
    "SparseTable": {
        "prefix": "DataStructure/SparseTable.cpp",
        "body": [
            "",
            "struct SparseTable {",
            "    vector<vector<int>> st;",
            "    vector<int> log_2;",
            "    void compute_log(int n) {",
            "        log_2.resize(n + 1, 0);",
            "        for (int i = 2; i <= n; i++) ",
            "            log_2[i] = log_2[i / 2] + 1;",
            "    }",
            "    SparseTable(const vector<int> &a) {",
            "        int n = a.size();",
            "        compute_log(n);",
            "        st.assign(n, vector<int>(log_2[n] + 1));",
            "",
            "        for (int i = 0; i < n; i++)",
            "            st[i][0] = a[i];",
            "            ",
            "        for (int j = 1; (1 << j) <= n; j++) {",
            "            int step = 1 << (j - 1);",
            "            for (int i = 0; i + 2 * step <= n; i++) {",
            "                st[i][j] = min(st[i][j - 1], st[i + step][j - 1]);",
            "            }",
            "        }",
            "    }",
            "    int query(int l, int r) {",
            "        int k = log_2[r - l + 1];",
            "        return min(st[l][k], st[r - (1 << k) + 1][k]);",
            "    }",
            "};"
        ],
        "description": "SparseTable\nVerified: https://cses.fi/problemset/task/1647"
    },
    "SegmentTree": {
        "prefix": "DataStructure/SegmentTree.cpp",
        "body": [
            "",
            "struct SegmentTree {",
            "    const int NONE = 0;",
            "    int n;",
            "    vector<long long> st, lz;",
            "    SegmentTree(int n) {",
            "        this->n = n;",
            "        st.assign(4 * n + 1, NONE);",
            "        lz.assign(4 * n + 1, NONE);",
            "    }",
            "    SegmentTree(const vector<int> &a) : SegmentTree(a.size()) {",
            "        build(0, 0, n - 1, a);",
            "    }",
            "    long long merge(const long long &a, const long long &b) const {",
            "        return a + b;",
            "    }",
            "    void build(int id, int l, int r, const vector<int> &a) {",
            "        if (l == r) {",
            "            st[id] = a[l];",
            "        } else {",
            "            int m = (l + r) / 2;",
            "            build(id * 2 + 1, l, m, a);",
            "            build(id * 2 + 2, m + 1, r, a);",
            "            st[id] = merge(st[id * 2 + 1], st[id * 2 + 2]);",
            "        }",
            "    }",
            "    void down(int id, int l, int r) {",
            "        if (l != r) {",
            "            lz[2 * id + 1] = merge(lz[2 * id + 1], lz[id]);",
            "            lz[2 * id + 2] = merge(lz[2 * id + 2], lz[id]);",
            "            st[2 * id + 1] = merge(st[2 * id + 1], lz[id]);",
            "            st[2 * id + 2] = merge(st[2 * id + 2], lz[id]);",
            "        }",
            "        lz[id] = NONE;",
            "    }",
            "    void update(int id, int l, int r, int fr, int to, int val) {",
            "        if (r < fr || to < l)",
            "            return;",
            "        if (fr <= l && r <= to) {",
            "            st[id] = merge(st[id], val);",
            "            lz[id] = merge(lz[id], val);",
            "            return;",
            "        }",
            "        if (lz[id] != NONE)",
            "            down(id, l, r);",
            "        int m = (l + r) / 2;",
            "        update(2 * id + 1, l, m, fr, to, val);",
            "        update(2 * id + 2, m + 1, r, fr, to, val);",
            "        st[id] = merge(st[2 * id + 1], st[2 * id + 2]);",
            "    }",
            "    void update(int fr, int to, int val) {",
            "        update(0, 0, n - 1, fr, to, val);",
            "    }",
            "    void update(int at, int val) {",
            "        update(0, 0, n - 1, at, at, val);",
            "    }",
            "    long long query(int id, int l, int r, int fr, int to) {",
            "        if (r < fr || to < l)",
            "            return NONE;",
            "        if (fr <= l && r <= to)",
            "            return st[id];",
            "        if (lz[id] != NONE)",
            "            down(id, l, r);",
            "        int m = (l + r) / 2;",
            "        return merge(",
            "            query(2 * id + 1, l, m, fr, to),",
            "            query(2 * id + 2, m + 1, r, fr, to)",
            "        );",
            "    }",
            "    long long query(int at) {",
            "        return query(0, 0, n - 1, at, at);",
            "    }",
            "    long long query(int fr, int to) {",
            "        return query(0, 0, n - 1, fr, to);",
            "    }",
            "};"
        ],
        "description": "SegmentTree\nVerified: https://cses.fi/problemset/submit/1651/"
    },
    "DisjoinSet": {
        "prefix": "DataStructure/DisjoinSet.cpp",
        "body": [
            "",
            "int n, m;",
            "vector<int> parent, setSize;",
            "",
            "void makeSet(int n) {",
            "    parent.resize(n);",
            "    setSize.resize(n, 1);",
            "    iota(parent.begin(), parent.end(), 0);",
            "}",
            "",
            "int findSet(int u) {",
            "    return parent[u] == u ? u : parent[u] = findSet(parent[u]);",
            "}",
            "",
            "bool unionSet(int u, int v) {",
            "    u = findSet(u);",
            "    v = findSet(v);",
            "    if (u == v) return false;",
            "    if (setSize[u] < setSize[v]) swap(u, v);",
            "    parent[v] = u;",
            "    setSize[u] += setSize[v];",
            "    return true;",
            "}",
            "",
            "int main() {",
            "    cin.tie(nullptr)->sync_with_stdio(false);",
            "    cin >> n >> m;",
            "    makeSet(n);",
            "    int components = n, maxSize = 1;",
            "    while(m--) {",
            "        int u, v;",
            "        cin >> u >> v;",
            "        --u, --v;",
            "        if (unionSet(u, v)) {",
            "            --components;",
            "            maxSize = max(maxSize, setSize[findSet(u)]);",
            "        }",
            "        cout << components << ' ' << maxSize << '\\n';",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "DisjoinSet\nVerified: https://cses.fi/problemset/task/1676/"
    },
    "IndexedSet": {
        "prefix": "DataStructure/IndexedSet.cpp",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "",
            "using namespace __gnu_pbds;",
            "",
            "typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;",
            "",
            "int main() {",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(0);",
            "    indexed_set s;",
            "    s.insert(2);",
            "    auto x = s.find_by_order(2);",
            "    cout << *x << endl;",
            "    cout << s.order_of_key(6) << \"\\n\"; // 2    ",
            "    return 0;",
            "}"
        ],
        "description": "IndexedSet\nVerified: https://cses.fi/problemset/task/1144/"
    },
    "FloydWarshall": {
        "prefix": "Graph/FloydWarshall.cpp",
        "body": [
            "",
            "void FloydWarshall(vector<vector<long long>> &dist) {",
            "    const long long INF = 1e18;",
            "    int n = dist.size();",
            "    for (int k = 0; k < n; ++k)",
            "        for (int i = 0; i < n; ++i)",
            "            for (int j = 0; j < n; ++j)",
            "                if (dist[i][k] < INF && dist[k][j] < INF)",
            "                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); ",
            "}"
        ],
        "description": "FloydWarshall\nVerified: https://cses.fi/problemset/task/1672"
    },
    "Prim": {
        "prefix": "Graph/Prim.cpp",
        "body": [
            "",
            "const long long INF = 1e18;",
            "",
            "using pii = pair<long long, int>;",
            "",
            "int n, m;",
            "vector<vector<pair<int, int>>> adj;",
            "vector<long long> dist;",
            "vector<int> path;",
            "vector<bool> visited;",
            "long long mst;",
            "bool Prim() {",
            "    dist.assign(n, INF);",
            "    path.assign(n, -1);",
            "    visited.assign(n, false);",
            "    priority_queue<pii, vector<pii>, greater<pii>> pq;",
            "    pq.push({0, 0});",
            "    dist[0] = 0;",
            "    int u, v, w;",
            "    int cnt = 0;",
            "    mst = 0;",
            "    while (!pq.empty()) {",
            "        u = pq.top().second;",
            "        pq.pop();",
            "        if (visited[u]) continue;",
            "        visited[u] = true;",
            "        mst += dist[u];",
            "        cnt++;",
            "        for (auto &e : adj[u]) {",
            "            tie(v, w) = e;",
            "            if (!visited[v] && w < dist[v]) {",
            "                dist[v] = w;",
            "                path[v] = u;",
            "                pq.push({dist[v], v});",
            "            }",
            "        }",
            "    }",
            "    return cnt == n;",
            "}",
            "",
            "int main() {",
            "    cin.tie(nullptr)->sync_with_stdio(false);",
            "    cin >> n >> m;",
            "    adj.resize(n);",
            "    for (int i = 0; i < m; i++) {",
            "        int u, v, c;",
            "        cin >> u >> v >> c;",
            "        u--, v--;",
            "        adj[u].push_back({v, c});",
            "        adj[v].push_back({u, c});",
            "    }",
            "    if (Prim())",
            "        cout << mst;",
            "    else",
            "        cout << \"IMPOSSIBLE\";",
            "    return 0;",
            "}"
        ],
        "description": "Prim\nVerified: https://cses.fi/problemset/task/1675/"
    },
    "read-adj": {
        "prefix": "Graph/read-adj.cpp",
        "body": [
            "vector<vector<int>> adj;",
            "int n, m;",
            "cin >> n >> m;",
            "adj.resize(n);",
            "for (int u, v, i = 0; i < m; i++) {",
            "    cin >> u >> v;",
            "    u--, v--;",
            "    adj[u].push_back(v);",
            "    adj[v].push_back(u);",
            "}"
        ],
        "description": "read-adj"
    },
    "2-SAT": {
        "prefix": "Graph/2-SAT.cpp",
        "body": [
            "",
            "vector<vector<int>> adj, revAdj, compList;",
            "vector<bool> visited, assignment;",
            "vector<int> order, comp;",
            "",
            "void dfs1(int u) {",
            "    visited[u] = true;",
            "",
            "    for (int v : adj[u])",
            "        if (!visited[v])",
            "            dfs1(v);",
            "",
            "    order.push_back(u);",
            "}",
            "",
            "void dfs2(int u) {",
            "    visited[u] = true;",
            "",
            "    compList.back().push_back(u);",
            "    comp[u] = compList.size() - 1;",
            "",
            "    for (int v : revAdj[u])",
            "        if (!visited[v])",
            "            dfs2(v);",
            "}",
            "",
            "void Kosaraju(int n) {",
            "    visited.assign(n, false);",
            "    for (int i = 0; i < n; i++)",
            "        if (!visited[i])",
            "            dfs1(i);",
            "",
            "    visited.assign(n, false);",
            "    comp.assign(n, -1);",
            "    reverse(order.begin(), order.end());",
            "",
            "    for (int v : order)",
            "        if (!visited[v]) {",
            "            compList.push_back(vector<int>());",
            "            dfs2(v);",
            "        }",
            "}",
            "",
            "bool solve2SAT(int n) {",
            "    Kosaraju(n);",
            "    assignment.assign(n / 2 - 1, false);",
            "    for (int i = 0; i < n; i += 2) {",
            "        if (comp[i] == comp[i + 1])",
            "            return false;",
            "        assignment[i / 2] = comp[i] > comp[i + 1];",
            "    }",
            "    return true;",
            "}",
            "",
            "void add_disjunction(int a, bool na, int b, bool nb) {",
            "    // na and nb are true then a and b are to be negated ",
            "    // k is denoted by 2k if k is positive and 2k+1 if k is negative",
            "    a = (a << 1) ^ na;",
            "    b = (b << 1) ^ nb;",
            "    int neg_a = a ^ 1;",
            "    int neg_b = b ^ 1;",
            "    adj[neg_a].push_back(b);",
            "    adj[neg_b].push_back(a);",
            "    revAdj[b].push_back(neg_a);",
            "    revAdj[a].push_back(neg_b);",
            "}",
            "",
            "",
            "int main() {",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(0);",
            "    int n, m;",
            "    cin >> m >> n;",
            "    n = (n << 1) + 2;",
            "    adj.assign(n, vector<int>());",
            "    revAdj.assign(n, vector<int>());",
            "",
            "    for (int i = 0; i < m; i++) {",
            "        char wish1, wish2; ",
            "        int topping1, topping2; ",
            "        cin >> wish1 >> topping1;",
            "        cin >> wish2 >> topping2;",
            "        topping1--, topping2--;",
            "        add_disjunction(topping1, wish1 == '-', topping2, wish2 == '-');",
            "    }",
            "",
            "    if (solve2SAT(n)) {",
            "        for (int i = 0; i < n / 2 - 1; i++)",
            "            cout << (assignment[i] ? '+' : '-') << ' ';",
            "    } else {",
            "        cout << \"IMPOSSIBLE\" << endl;",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "2-SAT\nVerified: https://cses.fi/problemset/task/1684/"
    },
    "BellmanFord": {
        "prefix": "Graph/BellmanFord.cpp",
        "body": [
            "",
            "const long long INF = 1e18;",
            "vector<tuple<int, int, int>> edges;",
            "vector<vector<int>> adj;",
            "",
            "void dfs(int u, vector<bool> &visited) {",
            "    visited[u] = true;",
            "    for (int v : adj[u])",
            "        if (!visited[v])",
            "            dfs(v, visited);",
            "}",
            "void BellmanFord(vector<long long> &dist, vector<int> &pre) {",
            "    int n = dist.size();",
            "    vector<int> lastChange;",
            "    for (int i = 0; i < n; i++) {",
            "        for (auto e : edges) {",
            "            int u, v, w;",
            "            tie(u, v, w) = e;",
            "            if (dist[u] != INF && dist[u] + w < dist[v]) {",
            "                dist[v] = dist[u] + w;",
            "                pre[v] = u;",
            "                if (i == n - 1)",
            "                    lastChange.push_back(v);",
            "            }",
            "        }",
            "    }",
            "    vector<bool> visited(n, false);",
            "    for (int i : lastChange)",
            "        dfs(i, visited);",
            "    for (int i = 0; i < n; i++) ",
            "        if (visited[i])",
            "            dist[i] = -INF;",
            "}"
        ],
        "description": "BellmanFord\nVerified: https://cses.fi/problemset/task/1673/"
    },
    "Dijkstra": {
        "prefix": "Graph/Dijkstra.cpp",
        "body": [
            "",
            "using ll = long long;",
            "const ll INF = 1e18;",
            "vector<vector<pair<int, int>>> adj;",
            "vector<int> pre;",
            "",
            "ll Dijkstra(int s, int t) {",
            "    int n = adj.size();",
            "    vector<ll> dist;",
            "    dist.assign(n, INF);",
            "    pre.assign(n, -1);",
            "",
            "    dist[s] = 0;",
            "    using pii = pair<ll, int>;",
            "    priority_queue<pii, vector<pii>, greater<pii>> pq;",
            "    pq.push({0, s});",
            "",
            "    while (!pq.empty()) {",
            "        auto [distU, u] = pq.top();",
            "        pq.pop();",
            "",
            "        if (distU != dist[u])",
            "            continue;",
            "",
            "        for (auto edge : adj[u]) {",
            "            auto [v, w] = edge;",
            "            if (dist[v] > distU + w) {",
            "                pre[v] = u;",
            "                dist[v] = distU + w;",
            "                pq.push({dist[v], v});",
            "            }",
            "        }",
            "    }",
            "    return dist[t];",
            "}"
        ],
        "description": "Dijkstra\nVerified: https://cses.fi/problemset/task/1671/"
    },
    "BFS": {
        "prefix": "Graph/BFS.cpp",
        "body": [
            "int BFS(int s, int t) {",
            "    vector<int> dist, pre;",
            "    vector<bool> visited;",
            "",
            "    visited.resize(n, false);",
            "    dist.resize(n, -1);",
            "    pre.resize(n, -1);",
            "",
            "    queue<int> q;",
            "    dist[s] = 0;",
            "    visited[s] = true;",
            "    q.push(s);",
            "",
            "    while(!q.empty()) {",
            "        int u = q.front();",
            "        q.pop();",
            "        for (int v : adj[u])",
            "            if (!visited[v]) {",
            "                visted[v] = true;",
            "                dist[v] = dist[u] + 1;",
            "                pre[v] = u;",
            "                q.push(v);",
            "            }",
            "    }",
            "    return dist[t];",
            "}"
        ],
        "description": "BFS"
    },
    "Kruskal": {
        "prefix": "Graph/Kruskal.cpp",
        "body": [
            "",
            "const long long INF = 1e18;",
            "",
            "int n, m;",
            "vector<tuple<int, int, int>> edges;",
            "vector<int> parent, setSize;",
            "long long mst;",
            "",
            "void makeSet(int n) {",
            "    parent.resize(n);",
            "    setSize.resize(n, 1);",
            "    iota(parent.begin(), parent.end(), 0);",
            "}",
            "",
            "int findSet(int u) {",
            "    return parent[u] == u ? u : parent[u] = findSet(parent[u]);",
            "}",
            "",
            "bool unionSet(int u, int v) {",
            "    u = findSet(u);",
            "    v = findSet(v);",
            "    if (u == v) return false;",
            "    if (setSize[u] < setSize[v]) swap(u, v);",
            "    parent[v] = u;",
            "    setSize[u] += setSize[v];",
            "    return true;",
            "}",
            "",
            "bool Kruskal() {",
            "    makeSet(n);",
            "    sort(edges.begin(), edges.end());",
            "    int cnt = mst = 0;",
            "    for (auto e : edges) {",
            "        int u, v, w;",
            "        tie(w, u, v) = e;",
            "        if (unionSet(u, v)) {",
            "            mst += 1ll * w;",
            "            cnt++;",
            "        }",
            "    }",
            "",
            "    return cnt == n - 1;",
            "}",
            "",
            "int main() {",
            "    cin.tie(nullptr)->sync_with_stdio(false);",
            "    cin >> n >> m;",
            "    edges.resize(m);",
            "    for (auto &e : edges) {",
            "        int u, v, w;",
            "        cin >> u >> v >> w;",
            "        --u, --v;",
            "        e = {w, u, v};",
            "    }",
            "    if (Kruskal())",
            "        cout << mst;",
            "    else",
            "        cout << \"IMPOSSIBLE\";",
            "    return 0;",
            "}"
        ],
        "description": "Kruskal\nVerified: https://cses.fi/problemset/task/1675/"
    },
    "SCC": {
        "prefix": "Graph/SCC.Tarjan.cpp",
        "body": [
            "",
            "vector<vector<int>> adj;",
            "vector<int> low, num, comp;",
            "vector<bool> found;",
            "stack<int> st;",
            "vector<vector<int>> compList;",
            "int counter;",
            "",
            "void dfs(int u) {",
            "    num[u] = low[u] = ++counter;",
            "    st.push(u);",
            "    for (int v : adj[u]) {",
            "        if (!found[v]) {",
            "            if (num[v] > 0)",
            "                low[u] = min(low[u], num[v]);",
            "            else {",
            "                dfs(v);",
            "                low[u] = min(low[u], low[v]);",
            "            }",
            "        }",
            "    }",
            "    if (num[u] == low[u]) {",
            "        // Found a new component",
            "        int v;",
            "        compList.push_back(vector<int>());",
            "        do {",
            "            v = st.top();",
            "            st.pop();",
            "            compList.back().push_back(v);",
            "            comp[v] = compList.size() - 1;",
            "            found[v] = true;",
            "        } while (v != u);",
            "    }",
            "}",
            "",
            "void Tarjan(int n) {",
            "    counter = 0;",
            "    low.assign(n, 0);",
            "    num.assign(n, 0);",
            "    comp.assign(n, -1);",
            "    found.assign(n, false);",
            "    st = stack<int>();",
            "    for (int i = 0; i < n; i++)",
            "        if (!num[i]) ",
            "            dfs(i);",
            "}",
            "",
            "int main() {",
            "    cin.tie(nullptr)->sync_with_stdio(false);",
            "    int n, m;",
            "    cin >> n >> m;",
            "    adj.resize(n);",
            "    while (m--) {",
            "        int u, v;",
            "        cin >> u >> v;",
            "        --u, --v;",
            "        adj[u].push_back(v);",
            "    }",
            "    Tarjan(n);",
            "    return 0;",
            "}"
        ],
        "description": "SCC\nVerified: https://cses.fi/problemset/task/1682/\nVerified: https://cses.fi/problemset/task/1683/"
    },
    "restore-path": {
        "prefix": "Graph/restore-path.cpp",
        "body": [
            "vector<int> restorePath(int s, int t) {",
            "    vector<int> path;",
            "    for (int v = t; v != s; v = pre[v])",
            "        path.push_back(v);",
            "    path.push_back(s);",
            "    reverse(path.begin(), path.end());",
            "    return path;",
            "}"
        ],
        "description": "restore-path"
    },
    "LowestCommonAncestor": {
        "prefix": "Graph/LowestCommonAncestor.cpp",
        "body": [
            "",
            "int n, l;",
            "vector<vector<int>> adj, parent;",
            "vector<int> tin, tout;",
            "int counter;",
            "",
            "void dfs(int u, int p) {",
            "    tin[u] = ++counter;",
            "    parent[u][0] = p;",
            "    for (int v : adj[u])",
            "        if (v != p)",
            "            dfs(v, u);",
            "    tout[u] = ++counter;",
            "}",
            "void preprocess() {",
            "    l = log2(n) + 1;",
            "    tin.resize(n);",
            "    tout.resize(n);",
            "    parent.resize(n, vector<int>(l));",
            "    counter = 0;",
            "    dfs(0, 0);",
            "    for (int k = 1; k < l; k++)",
            "        for (int i = 0; i < n; i++)",
            "            parent[i][k] = parent[parent[i][k - 1]][k - 1];",
            "}",
            "int isAncestor(int u, int v) {",
            "    return tin[u] <= tin[v] && tin[v] <= tout[u];",
            "}",
            "int lca(int u, int v) {",
            "    if (isAncestor(u, v)) return u;",
            "    if (isAncestor(v, u)) return v;",
            "    for (int k = l - 1; k >= 0; k--)",
            "        if (!isAncestor(parent[u][k], v))",
            "            u = parent[u][k];",
            "    return parent[u][0];",
            "}",
            "",
            "int main() {",
            "    cin.tie(nullptr)->sync_with_stdio(false);",
            "    int q;",
            "    cin >> n >> q;",
            "    adj.resize(n);",
            "    for (int i = 1; i < n; i++) {",
            "        int u; cin >> u;",
            "        u--;",
            "        adj[i].push_back(u);",
            "        adj[u].push_back(i);",
            "    }",
            "    preprocess();",
            "    while (q--) {",
            "        int u, v;",
            "        cin >> u >> v;",
            "        u--;",
            "        v--;",
            "        cout << lca(u, v) + 1 << endl;",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "LowestCommonAncestor\nVerified: https://cses.fi/problemset/task/1688/\nVerified: https://cses.fi/problemset/task/1135"
    },
    "DFS": {
        "prefix": "Graph/DFS.cpp",
        "body": [
            "vector<bool> visited;",
            "void dfs(int u) {",
            "    visited[u] = true;",
            "    for (int v : adj[u])",
            "        if (visited[v] == false)",
            "            dfs(v);",
            "}",
            "visited.resize(n, false);"
        ],
        "description": "DFS"
    },
    "EulerCycle": {
        "prefix": "Graph/EulerCycle.cpp",
        "body": [
            "",
            "vector<int> Hierholzer(vector<vector<int>> adj, int u) { ",
            "    // Directed graph",
            "    stack<int> path;",
            "    vector<int> circuit;",
            "    path.push(u);",
            "    while (!path.empty()) {",
            "        if (!adj[u].empty()) {",
            "            path.push(u);",
            "            int v = adj[u].back();",
            "            adj[u].pop_back();",
            "            u = v;",
            "        }",
            "        else {",
            "            circuit.push_back(u);",
            "            u = path.top();",
            "            path.pop();",
            "        }",
            "    }",
            "    reverse(circuit.begin(), circuit.end());",
            "    return circuit;",
            "}",
            "",
            "",
            "vector<int> Hierholzer(vector<set<int>> adj, int u) {",
            "    // Undirected graph",
            "    stack<int> path;",
            "    vector<int> circuit;",
            "    path.push(u);",
            "    while (!path.empty()) {",
            "        if (!adj[u].empty()) {",
            "            path.push(u);",
            "            int v = *adj[u].begin();",
            "            adj[u].erase(v);",
            "            adj[v].erase(u);",
            "            u = v;",
            "        }",
            "        else {",
            "            circuit.push_back(u);",
            "            u = path.top();",
            "            path.pop();",
            "        }",
            "    }",
            "    reverse(circuit.begin(), circuit.end());",
            "    return circuit;",
            "}"
        ],
        "description": "EulerCycle\nVerified: https://cses.fi/problemset/task/1693/\nVerified: https://cses.fi/problemset/task/1691/"
    }
}